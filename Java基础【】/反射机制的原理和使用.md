# 反射机制--练习实例
我将所有创建的.java文件都放在包text下，演示一个电脑运行的实例，电脑具有一个主板类，通过反射机制，我们可以扩展其功能，添加声卡。网卡等。
主函数类：
```java
package text;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Properties;

/**
 * 电脑运行
 **/

public class ReflectTest {

	public static void main(String[] args) throws Exception {

		Mainboard mb=new Mainboard();

		mb.run();

		//每次添加一个设备都需要修改代码传递一个新创建的对象

		//mb.usePCI(new SoundCard());

		//能不能不修改代码就可   以完成这个动作

		//不用new来完.成，而是直接获取其class文件，在内部实现创建对象的动作

		File configFile=new File("pci.properties");  //把配置文件封装成对象
		Properties prop=new Properties();
		FileInputStream fis=new FileInputStream(configFile);
		prop.load(fis);  //把流里的数据加载到集合中
		for(int x=0;x<prop.size();x++){    //遍历
			String pciName = prop.getProperty("pci"+(x+1));		
			Class clazz=Class.forName(pciName);
			PCI p=(PCI)clazz.newInstance();
			mb.usePCI(p);
		}
		fis.close();
	}
}
```

主板类：
```java
package text;

public class Mainboard {

	public void run(){
		System.out.println("main board run....");
	}

	public void usePCI(PCI p){   //PCI p=new SoundCard();

		if(p!=null){

			p.open();

			p.close();

		}

	}

}
```

PCI接口：
```java
package text;

public interface PCI {

	public void open();

	public void close();

}
```

配置文件：读取配置文件中的类名
```java
pci1=text.SoundCard
pci2=text.NetCard
```

声卡类：实现PCI接口

```java
package text;

public class SoundCard implements PCI{

	public void open(){

		System.out.println("sound open");

	}

	public void close(){

		System.out.println("sound close");

	}

}
```

网卡类：
```java
package text;

public class NetCard implements PCI {

	@Override
	public void open() {

		// TODO Auto-generated method stub
		System.out.println("net open");

	}

	@Override
	public void close() {

		// TODO Auto-generated method stub

		System.out.println("net close");

	}

}
```

运行结果：

![img](https://img-blog.csdn.net/20160512111112383)

扩展程序的功能，就是实现PCI接口，然后将类名存储到配置文件中即可，不需要修改源代码。



# Java反射机制详解

​          Java让我们在运行时识别对象和类的信息，主要有2种方式：一种是传统的RTTI，RTTI，即Run-Time Type Identification，运行时类型识别。RTTI能在运行时就能够自动识别每个编译时已知的类型。它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。

###  

### (1).获取类信息

举例，有一个testreflection.Student类

```java
package testreflection;

public class Student {

	public Student(String sex, int age) {

             this.sex=sex;



	     this.age=age;



	}



	public Student() {};



        private String sex="男";



        private int age=15;



 



        public String getSex() {



            return sex;



        }



 



        public void setSex(String sex) {



            this.sex = sex;



        }



       



        public int getAge() {



            return age;



        }



 



        public void setAge(int age) {



            this.age = age;



        }



 



        public void study()



        {



        	System.out.println(sex + " "+ String.valueOf(age)+ "  好好学习");



        }



  }
```

测试类：

```java
package testreflection;



import org.junit.Test;



 



import java.lang.reflect.Constructor;



import java.lang.reflect.Field;



import java.lang.reflect.Method;



 



public class testor



{



	@Test



	 public void test() throws ClassNotFoundException



	 {



	    Class<?> clazz=Class.forName("testreflection.Student");



	    Field[] field=clazz.getDeclaredFields();



 



		System.out.println("----------显示类的属性----------------------------");



	    for(Field f:field)



	    {



	    	System.out.println(f.getName()+"   "+f.getType());



	    }



	    System.out.println("----------显示类的方法-----------------------------");



	    Method[] methods=clazz.getDeclaredMethods();



	    for(Method m:methods)



	    {



	    	System.out.println(m.getName());



	    }



	    System.out.println("---------显示类的构造方法-----------------------------");



	    Constructor[] constructors=clazz.getDeclaredConstructors();



	    for(Constructor<?> c: constructors)



	    {



	    	System.out.println(c);



	    }



	    System.out.println("---------获取类的相关的信息--------------------------");



	 	System.out.println("类所在的包为："+ clazz.getPackage().getName());



	 	System.out.println("类名："+ clazz.getName());



	 	System.out.println("父类的名称："+ clazz.getSuperclass().getName());  



	 } 



}
```

运行结果：
![img](https://img-blog.csdnimg.cn/20181226122654398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3djYzI3ODU3Mjg1,size_16,color_FFFFFF,t_70)

 这个例子通过java.lang.reflect中的反射，通过类的全名“testreflection.Student”就得到了该类的所有信息，这就是反射，这样就可以在运行时动态的获得类的信息，接下来要将如何生成Student类的实例对象

PS:Class<?>和Class，class有什么区别？
Class<?>和Class这两者并没有什么区别，最好写成Class<?>.
class是java中的关键字，而Class是一个类，就是可以看成Student类，Student类中有sex,age属性，Class类中则有和类相关的一些属性方法，如private transient String name、  public static Class<?> forName(String)，也就是说Class也是一个普通类，跟Student,Person并无二致
Student stu=new Student();  这里的stu就等价于上例中的clazz, 因为Class类构造函数是私有的：

 private Class(ClassLoader loader) {
​        classLoader = loader;
   }
所以只能通过静态方法如forName来得到实例clazz, 总而言之,Class就是一个包含类信息的普通类，跟Student一样

 

 

### (2)得到类Class的三种方式

```java
        @Test



	public void test2() throws ClassNotFoundException



	{



		//第一种,对象.getClass



		Student student=new Student();



		Class clazz=student.getClass();



		System.out.println(clazz.toString());



 



 



		//第二种，类名.class



		clazz=Student.class;



		System.out.println(clazz.toString());



 



 



		// 第三种：Class.forName("类的路径")



		clazz=Class.forName("testreflection.Student");



		System.out.println(clazz.toString());



	}
```

运行结果：
![img](https://img-blog.csdnimg.cn/20181226122840436.png)

 

### (3)使用反射动态创建对象实例的方式

```java
        @Test



	public void test3() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException



	{



		//方法1:通过Class的newInstance()方法



		//该方法要求该Class对象的对应类有无参构造方法



		//执行newInstance()实际上就是执行无参构造方法来创建该类的实例



		Class<?> clazz=Class.forName("testreflection.Student");



		Object obj =  clazz.newInstance();



		((Student)obj).study();



		



		//方法2：通过Constructor的newInstance()方法



		//先使用Clazz对象获取指定的Constructor对象



		//再调用Constructor对象的newInstance()方法来创建该Class对象对应类的对象



		//通过该方法可选择使用指定构造方法来创建对象



		Constructor constructor=clazz.getConstructor(new Class[] {String.class,int.class});



		Object obj1 =constructor.newInstance(new Object[]{"女",30});



		((Student)obj1).study();



		



		//以下也可以调用无参构造方法



		Object obj2 = clazz.getConstructor().newInstance();



                ((Student)obj2).study();



	}
```

运行结果：

男 15  好好学习
女 30  好好学习
男 15  好好学习

 

 

### (4)使用反射动态修改和查询字段的值

 getXxx(Object   obj) &  setXxx(Object obj,Xxx val) ：获取或设置obj对象该Field的属性值。此处的Xxx对应8个基本数据类型，如果该属性类型是引用类型则直接使用get(Objectobj)

setAccessible(Boolean flag)：若flag为true，则取消属性的访问权限控制，即使private属性也可以进行访问

 

```java
        @Test



	public void test4() throws ClassNotFoundException, InstantiationException, IllegalAccessException,



			NoSuchFieldException, SecurityException {



		Class<?> clazz = Class.forName("testreflection.Student");



		Object object = clazz.newInstance();



		//获得 Student类中的指定属性对应的Field对象



		Field field = clazz.getDeclaredField("age");



		



		//取消属性的访问权限控制，即使private 属性也可以进行访问



		field.setAccessible(true);



		



                //通过field对象获取真实field的值，有两种方式



		System.out.println(field.get(object));



		System.out.println(field.getInt(object));



		



                //通过field给真实对象中的field赋值



		field.set(object, 33);



		System.out.println(field.getInt(object));



	}
```

运行结果：

15
15
33

 

### （5）使用反射动态执行方法

通过Class对象的getMethods()方法可以获得该类所包括的全部方法，返回值是Method[]
通过Class对象的getMethod() 方法可以获得该类所包括的执行方法，返回值是Method
每个Method对象对应一个方法，获得Method对象后，可以调用其invoke()     来调用对应方法   

```java
        @Test



	public void test5()throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException,



			SecurityException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException {



		Class<?> clazz = Class.forName("testreflection.Student");



		Object obj = clazz.newInstance();



 



		//调用该对象的 setSex方法



		Method method = clazz.getMethod("setSex", new Class[] { String.class });



		Object result = method.invoke(obj, new Object[] { "iam a man" }); // obj.setName("iam a man");



 



		//调用对象的getSex()方法



		Method method1 = clazz.getMethod("getSex", new Class[] {});



		Object obj1 = method1.invoke(obj, new Object[] {});



		System.out.println("已设置为" + obj1);



	}
```

运行结果：

已设置为iam a man

 

### （6）使用反射动态创建数组并存取元素

在java.lang.reflect包提供了Array类，包括一系列static方法，可动态的创建数组、给元素赋值、取出元素值等                      
Array提供的主要方法如下：
static ObjectnewInstance(Class<?> componentType, int[] dim) ：创建一个具有指定的组件类型和维度的新数组
static void setXxx(Objectarray, int index ，xxx val)：给数组对象array中第index个元素赋值val
static xxx getXxx(Objectarray, int index)：以 xxx形式返回指定数组对象array中第index个元素值

```java
        @Test



	public void test6()throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException,



			SecurityException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException {



		Class clazz = Class.forName("java.lang.Integer");



		Object array = Array.newInstance(clazz, 10);// 根据类的class 创建大小为10的数组



		Array.set(array, 5, 111);// 给数组的第5个元素赋值为111



		Object el = Array.get(array, 5);// 取出数组的第5个元素值显示



		System.out.println(el);



	}
```

运行结果：

111

 

### 总结：

1.反射就是java.lang.reflect包所提供的一系列类和方法，里面包含了Class,Field,Method等类
2.Felid类跟Method，Class类本质上是一样的，他们都是用来保存class相关信息的类，跟Student类并无二致
3.通过反射，我们可以知道类的所有信息，可以动态创建类，调用类方法，查看修改类字段，动态创建类的数组等等



# [Java学习之反射机制及应用场景](https://www.cnblogs.com/whoislcj/p/6038511.html)

### 前言：

​      最近公司正在进行业务组件化进程，其中的路由实现用到了Java的反射机制，既然用到了就想着好好学习总结一下，其实无论是之前的EventBus 2.x版本还是Retrofit、早期的View注解框架都或多或少的用到Java的反射机制。以下是自己使用反射的两个地方，感兴趣的同学可以看下：[Android okHttp网络请求之Json解析](http://www.cnblogs.com/whoislcj/p/5533548.html)，[Android业务组件化之子模块SubModule的拆分以及它们之间的路由Router实现](http://www.cnblogs.com/whoislcj/p/5860138.html)。

### 什么是Java反射机制？

​     JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的以及动态调用对象的方法的功能称为Java的反射机制。

### 反射机制提供了哪些功能？

- 在运行时判定任意一个对象所属的类
- 在运行时构造任意一个类的对象；
- 在运行时判定任意一个类所具有的成员变量和方法；
- 在运行时调用任意一个对象的方法；
- 生成动态代理；

### Java反射机制类：

```
java.lang.Class; //类               
java.lang.reflect.Constructor;//构造方法 
java.lang.reflect.Field; //类的成员变量       
java.lang.reflect.Method;//类的方法
java.lang.reflect.Modifier;//访问权限
```

### Java反射机制实现：

#### 1.）class对象的获取

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
//第一种方式 通过对象getClass方法
Person person = new Person();
Class<?> class1 = person.getClass();
//第二种方式 通过类的class属性
class1 = Person.class;
try {
    //第三种方式 通过Class类的静态方法——forName()来实现
    class1 = Class.forName("com.whoislcj.reflectdemo.Person");
} catch (ClassNotFoundException e) {
    e.printStackTrace();
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 2.）获取class对象的摘要信息

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
boolean isPrimitive = class1.isPrimitive();//判断是否是基础类型
boolean isArray = class1.isArray();//判断是否是集合类
boolean isAnnotation = class1.isAnnotation();//判断是否是注解类
boolean isInterface = class1.isInterface();//判断是否是接口类
boolean isEnum = class1.isEnum();//判断是否是枚举类
boolean isAnonymousClass = class1.isAnonymousClass();//判断是否是匿名内部类
boolean isAnnotationPresent = class1.isAnnotationPresent(Deprecated.class);//判断是否被某个注解类修饰

String className = class1.getName();//获取class名字 包含包名路径
Package aPackage = class1.getPackage();//获取class的包信息
String simpleName = class1.getSimpleName();//获取class类名
int modifiers = class1.getModifiers();//获取class访问权限

Class<?>[] declaredClasses = class1.getDeclaredClasses();//内部类
Class<?> declaringClass = class1.getDeclaringClass();//外部类
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 3.）获取class对象的属性、方法、构造函数等

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
Field[] allFields = class1.getDeclaredFields();//获取class对象的所有属性
Field[] publicFields = class1.getFields();//获取class对象的public属性
try {
    Field ageField = class1.getDeclaredField("age");//获取class指定属性
    Field desField = class1.getField("des");//获取class指定的public属性
} catch (NoSuchFieldException e) {
    e.printStackTrace();
}

Method[] methods = class1.getDeclaredMethods();//获取class对象的所有声明方法
Method[] allMethods = class1.getMethods();//获取class对象的所有方法 包括父类的方法

Class parentClass = class1.getSuperclass();//获取class对象的父类
Class<?>[] interfaceClasses = class1.getInterfaces();//获取class对象的所有接口

Constructor<?>[] allConstructors = class1.getDeclaredConstructors();//获取class对象的所有声明构造函数
Constructor<?>[] publicConstructors = class1.getConstructors();//获取class对象public构造函数
try {
    Constructor<?> constructor = class1.getDeclaredConstructor(new Class[]{String.class});//获取指定声明构造函数
    Constructor publicConstructor = class1.getConstructor(new Class[]{});//获取指定声明的public构造函数
} catch (NoSuchMethodException e) {
    e.printStackTrace();
}

Annotation[] annotations = class1.getAnnotations();//获取class对象的所有注解
Annotation annotation = class1.getAnnotation(Deprecated.class);//获取class对象指定注解

Type genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 Type
Type[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的type集合
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 4.）class对象动态生成

```
//第一种方式 Class对象调用newInstance()方法生成
Object obj = class1.newInstance();
//第二种方式 对象获得对应的Constructor对象，再通过该Constructor对象的newInstance()方法生成
Constructor<?> constructor = class1.getDeclaredConstructor(new Class[]{String.class});//获取指定声明构造函数
obj = constructor.newInstance(new Object[]{"lcj"});
```

#### 5.）动态调用函数

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
try {
    // 生成新的对象：用newInstance()方法
    Object obj = class1.newInstance();
    //判断该对象是否是Person的子类
    boolean isInstanceOf = obj instanceof Person;
    //首先需要获得与该方法对应的Method对象
    Method method = class1.getDeclaredMethod("setAge", new Class[]{int.class});
    //调用指定的函数并传递参数
    method.invoke(obj, 28);
    method = class1.getDeclaredMethod("getAge");
    Object result = method.invoke(obj, new Class[]{});
} catch (InstantiationException e) {
    e.printStackTrace();
} catch (IllegalAccessException e) {
    e.printStackTrace();
} catch (NoSuchMethodException e) {
    e.printStackTrace();
} catch (InvocationTargetException e) {
    e.printStackTrace();
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 6.)通过反射机制获取泛型类型

例如下面这种结构

```
//People类
public class People<T> {}
//Person类继承People类
public class Person<T> extends People<String> implements PersonInterface<Integer> {}
//PersonInterface接口
public interface PersonInterface<T> {}
```

获取泛型类型

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
Person<String> person = new Person<>();
//第一种方式 通过对象getClass方法
Class<?> class1 = person.getClass();
Type genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 Type
Type[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的Type集合

getComponentType(genericSuperclass);
getComponentType(interfaceTypes[0]);
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
getComponentType具体实现
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
private Class<?> getComponentType(Type type) {
Class<?> componentType = null;
if (type instanceof ParameterizedType) {
    //getActualTypeArguments()返回表示此类型实际类型参数的 Type 对象的数组。
    Type[] actualTypeArguments = ((ParameterizedType) type).getActualTypeArguments();
    if (actualTypeArguments != null && actualTypeArguments.length > 0) {
    componentType = (Class<?>) actualTypeArguments[0];
    }
} else if (type instanceof GenericArrayType) {
    // 表示一种元素类型是参数化类型或者类型变量的数组类型
    componentType = (Class<?>) ((GenericArrayType) type).getGenericComponentType();
} else {
    componentType = (Class<?>) type;
}
return componentType;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 6.)通过反射机制获取注解信息

```
 这里重点以获取Method的注解信息为例
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
try {
    //首先需要获得与该方法对应的Method对象
    Method method = class1.getDeclaredMethod("jumpToGoodsDetail", new Class[]{String.class, String.class});
    Annotation[] annotations1 = method.getAnnotations();//获取所有的方法注解信息
    Annotation annotation1 = method.getAnnotation(RouterUri.class);//获取指定的注解信息
    TypeVariable[] typeVariables1 = method.getTypeParameters();
    Annotation[][] parameterAnnotationsArray = method.getParameterAnnotations();//拿到所有参数注解信息
    Class<?>[] parameterTypes = method.getParameterTypes();//获取所有参数class类型
    Type[] genericParameterTypes = method.getGenericParameterTypes();//获取所有参数的type类型
    Class<?> returnType = method.getReturnType();//获取方法的返回类型
    int modifiers = method.getModifiers();//获取方法的访问权限
} catch (NoSuchMethodException e) {
    e.printStackTrace();
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

###  反射机制的应用场景：

- 逆向代码 ，例如反编译
- 与注解相结合的框架 例如Retrofit
- 单纯的反射机制应用框架 例如EventBus 2.x
- 动态生成类框架 例如Gson

### 反射机制的优缺点：

 **优点：**

​    运行期类型的判断，动态类加载，动态代理使用反射。

 **缺点：**

​    性能是一个问题，反射相当于一系列解释操作，通知jvm要做的事情，性能比直接的java代码要慢很多。

### 总结：

​    Java的反射机制在平时的业务开发过程中很少使用到，但是在一些基础框架的搭建上应用非常广泛，今天简单的总结学习了一下，还有很多未知的知识等以后用到再做补充。

干我们这行，啥时候懈怠，就意味着长进的停止，长进的停止就意味着被淘汰，只能往前冲，直到凤凰涅槃的一天！



# 反射机制及反射原理

2018年04月25日 19:32:36 [坠落的流星1234](https://me.csdn.net/weixin_39304154) 阅读数：613





**反射机制：**Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。



**java反射机制有三个动态特性：**



（1）运行时生成对象实例。



（2）运行时调用方法.



（3）运行时更改属性。



**1.反射机制获取类有三种方法**



  **![img](https://img-blog.csdn.net/20180425191009531)**





**2.反射机制创建类对象**











**![img](https://img-blog.csdn.net/20180425192107819)**





**3.访问类的方法及属性**





**![img](https://img-blog.csdn.net/20180425192328274)**

**总结：使用反射虽然会很大程度上提高代码灵活性，但不能滥用反射，因为 通过反射创建对象时性能稍微低一些。实际上，只有当程序需要动态创建某个类的对象时才会考虑使用反射。通常在开发通用性比较广的框架，基础平台时可能大量使用反射。因为在很多java框架中都需要根据配置信息创建Java对象，从配置文件读取的只是某个类的字符串类名，程序员需要根据字符串来创建对应的实例，就必须使用java.**

﻿﻿Java反射机制的原理及作用

2017年04月19日 17:44:58 [WildGrasses](https://me.csdn.net/WildGrasses) 阅读数：6584



反射机制是Java特性之一，反射机制是构建框架技术的基础所在。灵活掌握Java反射机制，对大家以后学习框架技术有很大的帮助。

**那么什么是Java的反射呢？**

​       大家都知道，要让Java程序能够运行，那么就得让Java类要被Java虚拟机加载。Java类如果不被Java虚拟机加载，是不能正常运行的。现在我们运行的所有的程序都是在编译期的时候就已经知道了你所需要的那个类的已经被加载了。

Java的反射机制是在编译并不确定是哪个类被加载了，而是在程序运行的时候才加载、探知、自审。使用在编译期并不知道的类。这样的特点就是反射。

**那么Java反射有什么作用呢？**

假如我们有两个程序员，一个程序员在写程序的时候，需要使用第二个程序员所写的类，但第二个程序员并没完成他所写的类。那么第一个程序员的代码能否通过编译呢？这是不能通过编译的。利用Java反射的机制，就可以让第一个程序员在没有得到第二个程序员所写的类的时候，来完成自身代码的编译。

Java的反射机制它知道类的基本结构，这种对Java类结构探知的能力，我们称为Java类的“自审”。大家都用过Jcreator和eclipse。当我们构建出一个对象的时候，去调用该对象的方法和属性的时候。一按点，编译工具就会自动的把该对象能够使用的所有的方法和属性全部都列出来，供用户进行选择。这就是利用了Java反射的原理，是对我们创建对象的探知、自审。

**Class类**

​       要正确使用Java反射机制就得使用java.lang.Class这个类。它是Java反射机制的起源。当一个类被加载以后，Java虚拟机就会自动产生一个Class对象。通过这个Class对象我们就能获得加载到虚拟机当中这个Class对象对应的方法、成员以及构造方法的声明和定义等信息。

**反射API**

​       u**反射API用于反应在当前Java虚拟机中的类、接口或者对象信息**

u**功能—获取一个对象的类信息.**

​       **—获取一个类的访问修饰符、成员、方法、构造方法以及超类的信息.**

​       **—检获属于一个接口的常量和方法声明.**

​       **—创建一个直到程序运行期间才知道名字的类的实例.**

​       **—获取并设置一个对象的成员，甚至这个成员的名字是   在程序运行期间才知道.**

​       **—检测一个在运行期间才知道名字的对象的方法**

​       利用Java反射机制我们可以很灵活的对已经加载到Java虚拟机当中的类信息进行检测。当然这种检测在对运行的性能上会有些减弱，所以什么时候使用反射，就要靠业务的需求、大小，以及经验的积累来决定。

​       那么如何利用反射API在运行的时候知道一个类的信息呢？

代码示例：



[java]

 

view plain

 

copy









1. <span style="font-size:16px;">import java.lang.reflect.Field;  
2. import java.lang.reflect.Method;  
3. import javax.swing.JOptionPane;  
4. /** 
5.   *本类用于测试反射API，利用用户输入类的全路径， 
6. *找到该类所有的成员方法和成员属性 
7.   */  
8. public class MyTest {  
9. ​     /** 
10. ​     *构造方法 
11. ​     */  
12. ​    public MyTest(){  
13. ​       String classInfo=JOptionPane.showInputDialog(null,"输入类全路径");//要求用户输入类的全路径  
14. ​       try {  
15. ​           Class cla=Class.forName(classInfo);//根据类的全路径进行类加载，返回该类的Class对象  
16. ​            
17. ​           Method[] method=cla.getDeclaredMethods();//利用得到的Class对象的自审，返回方法对象集合  
18. ​            
19. ​           for(Method me:method){//遍历该类方法的集合  
20. ​              System.out.println(me.toString());//打印方法信息  
21. ​           }  
22. ​            
23. ​           System.out.println("********");  
24. ​            
25. ​           Field[] field=cla.getDeclaredFields();//利用得到的Class对象的自审，返回属性对象集合  
26. ​           for(Field me:field){ //遍历该类属性的集合  
27. ​              System.out.println(me.toString());//打印属性信息  
28. ​           }  
29. ​       } catch (ClassNotFoundException e) {  
30. ​           e.printStackTrace();  
31. ​       }  
32. ​    }  
33. ​    public static void main(String[] args) {  
34. ​       new MyTest();  
35. ​    }  
36. }</span>  

```java
import java.lang.reflect.Field;



import java.lang.reflect.Method;



import javax.swing.JOptionPane;



/**



  *本类用于测试反射API，利用用户输入类的全路径，



*找到该类所有的成员方法和成员属性



  */



public class MyTest {



     /**



     *构造方法



     */



    public MyTest(){



       String classInfo=JOptionPane.showInputDialog(null,"输入类全路径");//要求用户输入类的全路径



       try {



           Class cla=Class.forName(classInfo);//根据类的全路径进行类加载，返回该类的Class对象



          



           Method[] method=cla.getDeclaredMethods();//利用得到的Class对象的自审，返回方法对象集合



          



           for(Method me:method){//遍历该类方法的集合



              System.out.println(me.toString());//打印方法信息



           }



          



           System.out.println("********");



          



           Field[] field=cla.getDeclaredFields();//利用得到的Class对象的自审，返回属性对象集合



           for(Field me:field){ //遍历该类属性的集合



              System.out.println(me.toString());//打印属性信息



           }



       } catch (ClassNotFoundException e) {



           e.printStackTrace();



       }



    }



    public static void main(String[] args) {



       new MyTest();



    }



}
```



运行的时候，我们输入javax.swing.JFrame，那么运行结果如下：

public void javax.swing.JFrame.remove(java.awt.Component)

public void javax.swing.JFrame.update(java.awt.Graphics)

…………

********

public static final int javax.swing.JFrame.EXIT_ON_CLOSE

private int javax.swing.JFrame.defaultCloseOperation

…………

​    大家可以发现，类的全路径是在程序运行的时候，由用户输入的。所以虚拟机事先并不知道所要加载类的信息，这就是利用反射机制来对用户输入的类全路径来对类自身的一个自审。从而探知该类所拥有的方法和属性。

通过上面代码，大家可以知道编译工具为什么能够一按点就能列出用户当前对象的属性和方法了。它是先获得用户输入对象的字符串，然后利用反射原理来对这样的类进行自审，从而列出该类的方法和属性。

**使用反射机制的步骤：**

u**导入java.lang.relfect 包**

u**遵循三个步骤第一步是获得你想操作的类的 java.lang.Class 对象第二步是调用诸如 getDeclaredMethods 的方法第三步使用 反射API 来操作这些信息**

**获得Class对象的方法**

u**如果一个类的实例已经得到，你可以使用**

​       **【Class c = 对象名.getClass(); 】**

​      **例： TextField t = new TextField();**

​              **Class c = t.getClass();**

​              **Class s = c.getSuperclass();**

u**如果你在编译期知道类的名字，你可以使用如下的方法**

**Class c = java.awt.Button.class; 或者**

​         **Class c = Integer.TYPE;**

u**如果类名在编译期不知道, 但是在运行期可以获得, 你可以使用下面的方法**

​          **Class c = Class.forName(strg);**

   这样获得Class类对象的方法，其实是利用反射API把指定字符串的类加载到内存中，所以也叫类加载器加载方法。这样的话，它会把该类的静态方法和静态属性，以及静态代码全部加载到内存中。但这时候，对象还没有产生。所以为什么静态方法不能访问非静态属性和方法。因为静态方法和属性产生的时机在非静态属性和方法之前。

代码示例：



[java]

 

view plain

 

copy









1. <span style="font-size:16px;">package  com;  
2.    
3. public class MyTest {  
4. ​    public static void main(String[] args) {  
5. ​       TestOne  one=null;  
6. ​       try{  
7. ​       Class  cla=Class.forName("com.TestOne");//进行com.TestOne类加载，返回一个Class对象  
8. ​       System.out.println("********");  
9. ​       one=(TestOne)cla.newInstance();//产生这个Class类对象的一个实例，调用该类无参的构造方法，作用等同于new TestOne()  
10. ​       }catch(Exception e){  
11. ​           e.printStackTrace();  
12. ​       }  
13. ​       TestOne two=new TestOne();  
14.   System.out.println(one.getClass() == two.getClass());//比较两个TestOne对象的Class对象是否是同一个对象，在这里结果是true。说明如果两个对象的类型相同，那么它们会有相同的Class对象  
15. ​    }  
16. }  
17.    
18. class TestOne{  
19. ​    static{  
20. ​       System.out.println("静态代码块运行");  
21. ​    }  
22. ​    TestOne(){  
23. ​       System.out.println("构造方法");  
24. ​    }  
25. }</span>  

```java
package  com;



 



public class MyTest {



    public static void main(String[] args) {



       TestOne  one=null;



       try{



       Class  cla=Class.forName("com.TestOne");//进行com.TestOne类加载，返回一个Class对象



       System.out.println("********");



       one=(TestOne)cla.newInstance();//产生这个Class类对象的一个实例，调用该类无参的构造方法，作用等同于new TestOne()



       }catch(Exception e){



           e.printStackTrace();



       }



       TestOne two=new TestOne();



  System.out.println(one.getClass() == two.getClass());//比较两个TestOne对象的Class对象是否是同一个对象，在这里结果是true。说明如果两个对象的类型相同，那么它们会有相同的Class对象



    }



}



 



class TestOne{



    static{



       System.out.println("静态代码块运行");



    }



    TestOne(){



       System.out.println("构造方法");



    }



}
```



  以上代码过行的结果是：

静态代码块运行

***********

构造方法

构造方法



代码分析：

在进行Class.*forName*("com.TestOne")的时候，实际上是对com.TestOne进行类加载，这时候，会把静态属性、方法以及静态代码块都加载到内存中。所以这时候会打印出"静态代码块运行"。但这时候，对象却还没有产生。所以"构造方法"这几个字不会打印。当执行cla.newInstance()的时候，就是利用反射机制将Class对象生成一个该类的一个实例。这时候对象就产生了。所以打印"构造方法"。当执行到TestOne two=**new** TestOne()语句时，又生成了一个对象。但这时候类已经加载完毕，静态的东西已经加载到内存中，而静态代码块只执行一次，所以不用再去加载类，所以只会打印"构造方法"，而"静态代码块运行"不会打印。

反射机制不但可以例出该类对象所拥有的方法和属性，还可以获得该类的构造方法及通过构造方法获得实例。也可以动态的调用这个实例的成员方法。

代码示例：



[java]

 

view plain

 

copy









1. <span style="font-size:16px;">package reflect;  
2.    
3. import java.lang.reflect.Constructor;  
4.    
5.    
6. /** 
7.  \* 
8.  \* 本类测试反射获得类的构造器对象， 
9.  \* 并通过类构造器对象生成该类的实例 
10.  \* 
11.  */  
12. public class ConstructorTest {  
13.    
14. ​    public static void main(String[] args) {  
15. ​       try {  
16. ​           //获得指定字符串类对象  
17. ​           Class cla=Class.forName("reflect.Tests");  
18. ​           //设置Class对象数组，用于指定构造方法类型  
19. ​           Class[] cl=new Class[]{int.class,int.class};  
20. ​            
21. ​           //获得Constructor构造器对象。并指定构造方法类型  
22. ​           Constructor con=cla.getConstructor(cl);  
23. ​            
24. ​           //给传入参数赋初值  
25. ​           Object[] x={new Integer(33),new Integer(67)};  
26. ​            
27. ​           //得到实例  
28. ​           Object obj=con.newInstance(x);  
29. ​       } catch (Exception e) {  
30. ​           e.printStackTrace();  
31. ​       }  
32. ​    }  
33.    
34. }  
35.    
36. class Tests{  
37. ​    public Tests(int x,int y){  
38. ​       System.out.println(x+"    "+y);  
39. ​    }  
40. }</span>  

```java
package reflect;



 



import java.lang.reflect.Constructor;



 



 



/**



 *



 * 本类测试反射获得类的构造器对象，



 * 并通过类构造器对象生成该类的实例



 *



 */



public class ConstructorTest {



 



    public static void main(String[] args) {



       try {



           //获得指定字符串类对象



           Class cla=Class.forName("reflect.Tests");



           //设置Class对象数组，用于指定构造方法类型



           Class[] cl=new Class[]{int.class,int.class};



          



           //获得Constructor构造器对象。并指定构造方法类型



           Constructor con=cla.getConstructor(cl);



          



           //给传入参数赋初值



           Object[] x={new Integer(33),new Integer(67)};



          



           //得到实例



           Object obj=con.newInstance(x);



       } catch (Exception e) {



           e.printStackTrace();



       }



    }



 



}



 



class Tests{



    public Tests(int x,int y){



       System.out.println(x+"    "+y);



    }



}
```

运行的结果是” 33    67”。说明我们已经生成了Tests这个类的一个对象。 



# 反射机制

2018年05月13日 21:14:23

 

So_Band

 

阅读数：30

更多

个人分类： [反射机制](https://blog.csdn.net/So_Band/article/category/7661614)



Properties类是Hashtable类的子类，正如它的名字所暗示的，该对象在处理性文件时特别方便。properties类可以把Map对象和属性文件关联起来，从而可以把Map对象中的key-value对写入属性文件中，也可以吧属性文件中的“属性名=属性值”加到Map对象中。属性名和属性值都为字符串类型。所以，Properties里的key，value都是字符串类型。 
String getProperty(String key);//获取Properties中指定的属性名对应的属性值。

在实现此反射机制的时候，需要 
ReflecrDemo_4//相当于开机 
Mainbord//相当于主板 
SoudCard//相当于声卡 
PCI//之间的连接工具 
还需要一个配置文件。

![这里写图片描述](https://img-blog.csdn.net/20180513210517390?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvX0JhbmQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

具体实现： 
![这里写图片描述](https://img-blog.csdn.net/20180513210800120?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NvX0JhbmQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

PCI为一个接口，来实现加入的类，而主板是调用PCI 
reflectDemo_4

```
public class reflectDemo5 {
//电脑运行
    public static void main(String[] args) throws Exception {
        // TODO Auto-generated method stub
        Mainbord mb = new Mainbord();
        mb.run();

        //每次添加一个类就要都需要修改代码传递一个新创建的对象
        //能不能不修改代码就可以完成这些操作
        //不用new来完成，而是只获取七class文件，在内部实现创建对象的动作。

        File configFile = new File("pci.properties");//配置文件
        Properties prop = new Properties(); //配置文件
        FileInputStream fis = new FileInputStream(configFile);//查询此配置文件

        prop.load(fis);//将属性文件加载key-value对，把加载到的key-value对追加到Properties里
        for(int x=0;x<prop.size();x++) {
            String pciName = prop.getProperty("pci"+(x+1));//获取Properties中指定属性名对应的属性值

            Class clazz = Class.forName(pciName);//用Class去加载PCI这个子类

            PCI p = (PCI)clazz.newInstance();//强制转换为PCI
            mb.usePCI(p);//主板调用这个PCI
        }
        fis.close();
    }

}12345678910111213141516171819202122232425262728
```

MainCard

```
public class Mainbord   {
    public void run() {
        System.out.println(" Mainbord run .......");//主板运行
    }
    public void usePCI(PCI p) {//PCI p = new SoudCard();
        if(p!=null) {
            p.open();
            p.close();
        }
    }
}1234567891011
```

PCI

```
public interface PCI {
    public void open();
    public void close();
}
12345
```

SoundCard

```
public class SoudCard implements PCI {
    public void open() {
        System.out.println("SoudCard open....");
    }
    public void close() {
        System.out.println("SoudCard close....");
    }
}12345678
```

NetCard

```
public class NetCard implements PCI {

    @Override
    public void open() {
        System.out.println("NetCard open.....");
    }

    @Override
    public void close() {
        System.out.println("NetCard close.....");

    }

}1234567891011121314
```

配置文件：当需要加入新的类的时候，在配置文件上要进行新的添加，则不需要改动主类，则只需要实现该PCI这个功能即可。

```
pci1=day26.SoudCard
pci2=day26.NetCard
123
```


  【框架基础】：Java反射机制详解(一)

2016年11月29日 15:13:05

 

life is wonderful

 

阅读数：2544

 

标签： [框架](http://so.csdn.net/so/search/s.do?q=%E6%A1%86%E6%9E%B6&t=blog)[反射](http://so.csdn.net/so/search/s.do?q=%E5%8F%8D%E5%B0%84&t=blog)[Java反射机制](http://so.csdn.net/so/search/s.do?q=Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6&t=blog)[架构设计](http://so.csdn.net/so/search/s.do?q=%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1&t=blog)[框架基础](http://so.csdn.net/so/search/s.do?q=%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80&t=blog)更多

个人分类： [框架基础](https://blog.csdn.net/erlian1992/article/category/6546543)

所属专栏： [SSH框架学习之路](https://blog.csdn.net/column/details/13817.html)



版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/erlian1992/article/details/53392557

​        在学习框架设计之前，先来了解一下框架基础——Java反射机制。

​        一、什么是反射机制

​        反射机制是在程序运行状态时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都

能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。

主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应

用所描述行为的状态和相关的语义。

​       反射是Java语言中一种强大的工具，能够使我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在

组件之间进行源代码链接。

​       要让Java程序能够运行，就得让Java类被Java虚拟机加载。Java类如果不被Java虚拟机加载就不能正常运行。正

常情况下，我们运行的所有的程序在编译期时候就已经把那个类被加载了。

​       Java的反射机制是在编译时并不确定是哪个类被加载了，而是在程序运行的时候才加载、探知、自审。使用的是

在编译期并不知道的类。这样的编译特点就是Java反射。

​       简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在Java中，只要给定类的名字， 那么就可以通

过反射机制来获得类的所有信息。



​       二、反射机制能做什么

​       反射机制主要提供了以下功能： 

​       1.在运行时判断任意一个对象所属的类；

​       2.在运行时构造任意一个类的对象；

​       3.在运行时判断任意一个类所具有的成员变量和方法；

​       4.在运行时调用任意一个对象的方法；

​       5.生成动态代理；

​       6.进行反编译：.class(字节码文件)-->.java(源代码文件)；



​       三、Java反射的作用

​       假如有两个程序员，一个程序员在写程序的时需要使用第二个程序员所写的类，但第二个程序员并没完成他所写

的类。那么第一个程序员的代码是不能通过编译的。此时，利用Java反射的机制，就可以让第一个程序员在没有得到

第二个程序员所写的类的时候，来完成自身代码的编译。

​      Java的反射机制它知道类的基本结构，这种对Java类结构探知的能力，我们称为Java类的“自审”。如Eclipse

中，一按点，编译工具就会自动的把该对象能够使用的所有的方法和属性全部都列出来，供用户进行选择。这就是利

用了Java反射的原理，是对我们创建对象的探知、自审。   

  

​       四、反射机制的优点与缺点 

​       为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念。

​       静态编译：在编译时确定类型，绑定对象，即通过。 

​       动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低

类之间的藕合性。 

​       一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在JavaEE的开发中。

它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发

布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软

件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能 的更新，而采用反射机制的

话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。 

​       它的缺点是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它 满足我

们的要求。这类操作总是慢于只直接执行相同的操作。   

​       在下面我们会举一个比较简单的小例子。



​       五、一个简单的例子

​       首先我们先来编写一个静态加载类的示例：

​       Office.java源文件：



```java
class Office{



	public static void main(String[] args){



		



		//使用new创建对象是静态加载类，在编译时刻就需要加载所有可能使用到的类



		//通过加载加载类可以解决该问题



	    if("Word".equals(args[0])){



			Word w = new Word();



			w.start();



	    }



	    if("Excel".equals(args[0])){



			Excel e = new Excel();



		    e.start();



	    }



    } 



} 
```

​       使用javac进行编译：

​       ![img](https://img-blog.csdn.net/20161129145500501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
​       编译出错的原因我们大家都知道，就是找不到Word类和Excel类。

​       假设我们写好了Word类，Word.java源文件：



```java
class Word{



	public void start(){



	    System.out.println("word...starts...");



	}



}	
```

​       使用javac编译：

​       ![img](https://img-blog.csdn.net/20161129145645705?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
​       再次编译此程序还是不通过，因为找不到Excel类，那么我们需要的就是Word功能，不需要Excel功能，那么主要

的程序还是无法编译运行，我们所需要的功能还是无法使用，这就是静态加载的不足之处。如果主程序中有多个功

能，只要其中一个没有实现或者是错误的，那么这个主程序就无法编译运行。那么这就需要使用动态加载来进行类的

加载了。

​       下面就来通过反射来实现动态加载：

​       OfficeBetter.java源文件：



```java
class OfficeBetter{



	public static void main(String[] args){



	    try{    



			//动态加载类，在运行时刻加载



			Class clazz = Class.forName(args[0]);



			//通过类类型创建该类的对象



			OfficeAble oa = (OfficeAble)clazz.newInstance();



			oa.start();



		}catch(Exception e){



			e.printStackTrace();



		}



	} 



}    
```

​       在其中我们需要定义一个接口，那么我们的功能类需要实现这个接口规范，这个规范就是OfficeAble接口。

​       OfficeAble.java源文件：



```java
interface OfficeAble{



	public void start();



}	
```

​       我们来进行编译：

​       ![img](https://img-blog.csdn.net/20161129145927612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

​       我们对它们进行编译，那么编译就会顺利通过。纵然是我们没有实现一个功能类，我们的主程序依然会通过。下

面的我们实现的功能类只要实现这个接口规范，然后编译功能类，我们不编译主类就可以运行。

​       我们将先前的Word功能类进行改写，也就是实现OfficeAble接口规范：



```java
class Word implements OfficeAble{



	public void start(){



	    System.out.println("word...starts...");



	}



}	
```

​       编译运行：

​       ![img](https://img-blog.csdn.net/20161129150105504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

​       那么我们再扩展新的功能类Excel.java



```java
class Excel implements OfficeAble{



	public void start(){



	    System.out.println("excel...starts...");



	}



}	
```

​       编译运行：

​       ![img](https://img-blog.csdn.net/20161129150206212?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

​       

​       总结：

​       通常情况下，Java程序能够运行，必须要让Java类被虚拟机加载，如果不被Java虚拟机加载，程序不能运行。运

行的所有的程序都是在编译期的时候就已经知道了你所需要的那个类的已经被加载了。通过反射机制可以让程序在编

译期间并不需要加载某个类，而是在程序运行的时候才加载。
​       利用反射机制可以很灵活的对运行时已经加载到Java虚拟机当中的类信息进行检测。当然这种检测在对运行的性

能上会有些减弱，所以什么时候使用反射，就要靠业务的需求、大小，以及经验的积累来决定。

​       反射提高程序的灵活性和扩展性，低耦合。常用于系统架构和框架搭建。



# java反射机制与动态代理

2014年05月05日 13:03:03

 

流水无Qing

 

阅读数：4521

 

标签： [java反射机制](http://so.csdn.net/so/search/s.do?q=java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6&t=blog)[动态代理](http://so.csdn.net/so/search/s.do?q=%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86&t=blog) 更多

个人分类： [hadoop](https://blog.csdn.net/u011067360/article/category/1833989)[java](https://blog.csdn.net/u011067360/article/category/2218173)



在学习HadoopRPC时，用到了函数调用，函数调用都是采用的java的反射机制和动态代理来实现的，所以现在回顾下java的反射和动态代理的相关知识。

**一、反射**

JAVA反射机制定义： JAVA反射机制是java程序在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 

反射就是把Java类中的各种成分映射成相应的Java类。

Java反射机制主要提供了以下功能： 

1、在运行时判断任意一个对象所属的类；
2、在运行时构造任意一个类的对象；
3、在运行时判断任意一个类所具有的成员变量和方法；
4、在运行时调用任意一个对象的方法；
5、生成动态代理。

我们了解了反射机制的功能，那么我们如何具体来实现它呢？



 一个类中的每个成员都可以用相应的反射包中的一个类的实例对象来表示，通过Class类的方法可以得到这些实例对象；这个“成员”就包括：类的构造函数、成员变量、方法等一些信息。而他们所对应的反射包中的类分别是：Constructor类、Field类、Method类。

这里只要讲讲动态代理的知识。

**二、动态代理**

　　Java动态代理类位于Java.lang.reflect包下，一般主要涉及到以下两个类：
　　　　(1). Interface InvocationHandler：该接口中仅定义了一个方法Object：invoke(Object obj,Method method, Object[] args)。在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，如上例中的request()，args为该方法的参数数组。 这个抽象方法在代理类中动态实现。 

　　　　(2).Proxy：该类即为动态代理类，作用类似于上例中的ProxySubject，其中主要包含以下内容： 

　　　　　　Protected Proxy(InvocationHandler h)：构造函数，估计用于给内部的h赋值。 

　　　　　　Static Class getProxyClass (ClassLoader loader, Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。 

　　　　　　Static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法)。

　实例：

1、定义一个HelloWorld接口



```java
 /**



 * 定义一个HelloWorld接口



 * 



 * @author 



 *



 */



 public interface HelloWorld {



    public void sayHelloWorld();



}
```

2、类HelloWorldImpl是HelloWorld接口的实现



```java
 /**



 * 类HelloWorldImpl是HelloWorld接口的实现



 * 



 * @author 



 *



 */



 public class HelloWorldImpl implements HelloWorld{



 



    public void sayHelloWorld() {



        System.out.println("HelloWorld!");



    }



 



}
```

3、HelloWorldHandler是 InvocationHandler接口实现



```java
 import java.lang.reflect.InvocationHandler;



 import java.lang.reflect.Method;



 



 /**



 * 实现在方法调用前后向控制台输出两句字符串



 * 



 * @author 



 *



 */



 public class HelloWorldHandler implements InvocationHandler{



    //要代理的原始对象



     private Object obj;



    



    public HelloWorldHandler(Object obj) {



        super();



        this.obj = obj;



    }



 



    /**



     * 在代理实例上处理方法调用并返回结果



     * 



     * @param proxy 代理类



     * @param method 被代理的方法



     * @param args 该方法的参数数组



     */



    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {



        Object result = null;



        //调用之前



         doBefore();



        //调用原始对象的方法



        result=method.invoke(obj, args);



        //调用之后



        doAfter();



        return result;



    }



    



    private void doBefore(){



        System.out.println("before method invoke");



    }



    



    private void doAfter(){



        System.out.println("after method invoke");



    }



    



}
```

4、测试类



```java
import java.lang.reflect.InvocationHandler;



import java.lang.reflect.Proxy;



 



 



public class HelloWorldTest {



 



    public static void main(String[] args) {



        HelloWorld helloWorld=new HelloWorldImpl();



        InvocationHandler handler=new HelloWorldHandler(helloWorld);



        



        //创建动态代理对象



        HelloWorld proxy=(HelloWorld)Proxy.newProxyInstance(



                helloWorld.getClass().getClassLoader(), 



                helloWorld.getClass().getInterfaces(), 



                handler);



        proxy.sayHelloWorld();



    }



}
```

运行结果为：

before method invoke

HelloWorld

after method invoke

总结：

一个典型的动态代理创建对象过程可分为以下四个步骤：
1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(...);

2、通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类
Class clazz = Proxy.getProxyClass(classLoader,new Class[]{...});

3、通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型
Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});

4、通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));

为了简化对象创建过程，Proxy类中的newInstance方法封装了2~4，只需两步即可完成代理对象的创建。

生成的ProxySubject继承Proxy类实现Subject接口，实现的Subject的方法实际调用处理器的invoke方法，而invoke方法利用反射调用的是被代理对象的的方法（Object result=method.invoke(proxied,args)）

综合上面所说的，作为一个Dynamic Proxy，它必须满足以下三个条件：
​        1、实现了InvocationHandler接口，实现接口中定义的invoke方法；
​        2、包含接口实现类的实例；
​        3、通过Proxy.newProxyInstance方法实现Proxy与接口之间的绑定
再来回顾一下定义
 Dynamic Proxy是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些 interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然啦，这个Dynamic Proxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作   。



# Java反射机制的基本概念与使用

2016年10月08日 10:12:43

 

小草mlc

 

阅读数：11068

 

标签： [java](http://so.csdn.net/so/search/s.do?q=java&t=blog)[反射机制](http://so.csdn.net/so/search/s.do?q=%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6&t=blog)[class](http://so.csdn.net/so/search/s.do?q=class&t=blog) 更多

个人分类： [Java](https://blog.csdn.net/mlc1218559742/article/category/6288907)[反射机制](https://blog.csdn.net/mlc1218559742/article/category/6451395)



版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/mlc1218559742/article/details/52754310

本篇文章分为以下几个部分：

1.认识反射

2.反射的源头（Class类）

3.利用反射操作构造方法

4.利用反射调用类中的方法

5.反射中的invoke方法

6.利用反射调用类中的属性

反射在我们普通程序开发中基本使用不到，但是在我们底层的程序设计中使用特别广泛，例如代理模式、工厂模式等一些设计模式，包括我们使用的开发工具以及各大开源框架底层都使用到了反射的原理。所以掌握了Java的反射机制对我们理解各大开源框架都有很好的帮助。



**1.认识反射**

反射，从这个“反”字可以看出与我们平时正常的使用逻辑肯定不一样，那么到底什么地方不一样了？想要了解“反”，就得先了解一下“正”的概念。

在正常情况下，如果要使用一个类，必须要经过以下几个步骤：

（1）使用important导入类所在的包（类：java.lang.Class）

（2）通过关键字new进行类对象实例化（构造方法:java.lang.reflect.Constructor）

（3）产生对象可以使用“对象.属性”进行类中属性的调用(属性：java.lang.reflect.Field)

（4）通过“对象.方法()”调用类中的方法（方法：java.lang.reflect.Method）

括号中的红色字体是每个步骤对应反射中使用到的类，如果现在不了解，可以先不用管，后面会一一介绍，这里是为了方便进行比较。

在反射中，使用一个类并不需要导入类的所在包，只要知道类的完整路径就可以知道该类中的所有信息。

反射不需要有明确的类型对象，所有的对象都使用Object表示。可以直接用Object的与反射机制的混合调用类中的方法。



**2.反射的源头（Class类）**

在认识反射机制之前，必须要介绍一下Class类，Class类是整个反射操作的源头，该类的定义如下：



```java
public final class Class<T>



extends Object



implements Serializable, GenericDeclaration, Type, AnnotatedElement
```



Class类的实例表示正在运行的Java应用程序中的类和接口。

如果要想使用Class类进行操作，就必须首先产生Class类这个对象，一共有三种方法：

（1）Object类中提供了一个返回Class类的方法，定义如下：



```java
public final Class<?> getClass()
```



（2）利用“类.class”取得。

（3）利用Class类的Static方法取得。



```java
public static Class<?> forName(String className)



                        throws ClassNotFoundException
```

在程序开发过程中，使用第二种方法比较多。但是在程序框架设计中，都是使用第三种方法，也就是反射机制用到的方法。



class类实例化对象：

Class类如果使用forName()方法之后，就可以调用Class类中newInstance()无参构造函数方法进行操作，该方法定义如下：



```java
public T newInstance()



              throws InstantiationException,



                     IllegalAccessException
```

该方法表示创建此Class对象所表示的类的一个新实例。



具体实例如下：



```java
class Student {



 



	public Student() {



		System.out.println("Student类的构造方法");



	}



 



	@Override



	public String toString() {



		return "Student类的toString方法";



	}



}



 



public class ReflectDemo {



 



	public static void main(String[] args) throws Exception {



		Class<?> cls = Class.forName("com.iflytek.Student");



		// 相当于关键字实例化对象,Object obj = new Student();



		Object obj = cls.newInstance();



		System.out.println(obj);



	}



 



}
```

输出结果为：





```java
Student类的构造方法



Student类的toString方法
```



通过上面的实例可以看出，调用newInstace()方法时，程序会默认调用Student类的无参构造方法，并且获取到了Student类的实例化对象，可以调用Student类里面的方法属性。

**3.利用反射操作构造方法**

在Class类中有两个方法可以获取类中的构造方法，分别是：

获取类中所有的构造方法：



```java
public Constructor<?>[] getConstructors()



                                 throws SecurityException
```

获取类中指定的构造方法：





```java
public Constructor<T> getConstructor(Class<?>... parameterTypes)



                              throws NoSuchMethodException,



                                     SecurityException
```

这两个方法返回的都是反射包（java.lang.reflect.*）中的Constructor类，该类提供了单个构造方法的信息以及对它的访问权限。

下面以获取String类中的所有构造方法为例，代码如下：



```java
public class ReflectStringDemo {



	public static void main(String[] args) throws Exception{



		Class<?> cls = Class.forName("java.lang.String");



		//获取所有构造函数



		Constructor<?>[] cons = cls.getConstructors();



		//循环打印



		for (int i = 0; i < cons.length; i++) {



			System.out.println(cons[i]);



		}



	}



}
```

打印结果：





```java
public java.lang.String(byte[])



public java.lang.String(byte[],int,int)



public java.lang.String(byte[],java.nio.charset.Charset)



public java.lang.String(byte[],java.lang.String) throws java.io.UnsupportedEncodingException



public java.lang.String(byte[],int,int,java.nio.charset.Charset)



public java.lang.String(java.lang.StringBuilder)



public java.lang.String(java.lang.StringBuffer)



public java.lang.String(int[],int,int)



public java.lang.String(char[],int,int)



public java.lang.String(char[])



public java.lang.String(java.lang.String)



public java.lang.String()



public java.lang.String(byte[],int,int,java.lang.String) throws java.io.UnsupportedEncodingException



public java.lang.String(byte[],int)



public java.lang.String(byte[],int,int,int)
```

上面实例获取了String类中的所有构造方法，包括构造方法中的参数、异常等。

获取所有构造方法看上去并不难，如果想要进行指定构造方法的调用，则必须关注Constructor类，使用newInstance()方法进行实例。





```java
public T newInstance(Object... initargs)



              throws InstantiationException,



                     IllegalAccessException,



                     IllegalArgumentException,



                     InvocationTargetException
```

获取指定有参构造方法并且实例化对象实例：





```java
import java.lang.reflect.Constructor;



 



class Student2 {



	private String name;



 



	private Integer age;



 



	public Student2(String name, Integer age) {



		this.name = name;



		this.age = age;



	}



 



	@Override



	public String toString() {



		return "name:" + this.name + ";age:" + this.age;



	}



}



 



public class ReflectConstructorDemo {



 



	public static void main(String[] args) throws Exception {



		Class<?> cls = Class.forName("com.iflytek.Student2");



		Constructor<?> con = cls.getConstructor(String.class, Integer.class);



		// 这里就相当于Object obj = new Student2("马小超",20);



		Object obj = con.newInstance("马小超", 20);



		System.out.println(obj);



	}



 



}
```

打印结果：





```java
name:马小超;age:20
```

通过上面可以看出，如果要实例化一个对象，使用无参构造方法比有参构造方法简单的多，使用无参直接调用newInstance()方法，使用有参则先获取有参构造方法，再通过Constructor中的newInstance()方法，并用指定的初始化参数初始化改实例。很多框架中的底层代码默认都是使用无参构造方法来实例化对象，所以在简单Java类开发中都要明确给出无参构造方法。





**4.利用反射调用类中的方法**
获取类中的方法可以分为两大类，每个大类中又可以分为两小类，风别是：

获取包括父类集成而来的方法：

​         获取全部方法：

```java
public Method[] getMethods()



                    throws SecurityException
```

​         获取指定方法：

```java
public Method getMethod(String name,Class<?>... parameterTypes)



                                   throws NoSuchMethodException,



                                    SecurityException
```

获取本类中定义的方法：



​         获取全部方法：



```java
public Method[] getDeclaredMethods()



                            throws SecurityException
```

​         获取指定方法：





```java
public Method getDeclaredMethod(String name,



                                Class<?>... parameterTypes)



                         throws NoSuchMethodException,



                                SecurityException
```

实例：





```java
import java.lang.reflect.Method;



 



 



class Student3{



	public void fun(){};



	



	public void talk(){};



}



 



 



public class ReflectMethodStuDemo {



	public static void main(String[] args) throws ClassNotFoundException{



		Class<?> cls = Class.forName("com.iflytek.Student3");



		//获取本类中定义的方法



		Method[] method = cls.getDeclaredMethods();



		//循环打印



		for (int i = 0; i < method.length; i++) {



			System.out.println(method[i]);



		}



	}



}
```

打印结果：





```java
public void com.iflytek.Student3.fun()



public void com.iflytek.Student3.talk()
```





如果把上述代码中的getDeclaredMethods()换成getMethods(),打印出来的结果如下：



```java
public void com.iflytek.Student3.fun()



public void com.iflytek.Student3.talk()



public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException



public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException



public final void java.lang.Object.wait() throws java.lang.InterruptedException



public boolean java.lang.Object.equals(java.lang.Object)



public java.lang.String java.lang.Object.toString()



public native int java.lang.Object.hashCode()



public final native java.lang.Class java.lang.Object.getClass()



public final native void java.lang.Object.notify()



public final native void java.lang.Object.notifyAll()
```



使用getMethods()方法时，不仅获取到了Student3类中的方法，Object类中的所有方法也被获取到。

上面的程序是直接调用了Method类中的toString()方法输出的，输出格式并不是很理想，没有异常等相关信息。如果有需要，我们也可以自己整理拼接方法输出。

需要用到Method类中的如下几种方法：

getModifiers()：以整数形式返回此 Method 对象所表示方法的 Java 语言修饰符。

getReturnType()：返回一个 `Class` 对象，该对象描述了此`Method` 对象所表示的方法的正式返回类型。

getName()：以 `String` 形式返回此 `Method` 对象表示的方法名称。

getParameterTypes()：按照声明顺序返回 `Class` 对象的数组，这些对象描述了此`Method` 对象所表示的方法的形参类型。

getExceptionTypes()：返回 `Class` 对象的数组，这些对象描述了声明将此`Method` 对象表示的底层方法抛出的异常类型。

在这需要注意的是，利用getModifiers()获取修饰符并不是简单的输出public、static等，而是以整数形式返回所表示的方法的Java语言修饰符。可借助Modifier类的toString()方法来完成。

自己手动拼接输出类中的方法信息的具体代码如下：

```java
import java.lang.reflect.Method;



import java.lang.reflect.Modifier;



 



interface Message {



	public void get();



}



 



class Student1 implements Message {



 



	public void fun() {



	}



 



	public void print() {



	}



 



	public void get() {



	}



}



 



public class ReflectMethodDemo {



 



	public static void main(String[] args) throws Exception {



		Class<?> cls = Class.forName("com.iflytek.Student1");



		Method[] me = cls.getMethods();



		for (int i = 0; i < me.length; i++) {



			// 此时用了method的toString方法输出，如果有需要，用户也可以自己拼凑输出



			// System.out.println(me[i]);



			// 取得修饰符



			System.out.print(Modifier.toString(me[i].getModifiers()) + " ");



			// 取得返回值类型



			System.out.print(me[i].getReturnType().getSimpleName() + " ");



			// 取得方法名称



			System.out.print(me[i].getName() + "(");



			// 取得方法参数



			Class<?> params[] = me[i].getParameterTypes();



			if (params.length > 0) {



				for (int j = 0; j < params.length; j++) {



					System.out.print(params[j].getSimpleName() + " arg-" + j);



					if (j < params.length - 1) {



						System.out.print(", ");



					}



				}



			}



			System.out.print(") ");



			// 取得异常



			Class<?>[] exp = me[i].getExceptionTypes();



			if (exp.length > 0) {



				System.out.print("throws ");



				for (int j = 0; j < exp.length; j++) {



					System.out.print(exp[j].getSimpleName());



					if (j < exp.length - 1) {



						System.out.println(", ");



					}



				}



			}



			System.out.println("{}");



			System.out.println();



		}



	}



}
```

打印结果：



```java
public void get() {}



 



public void print() {}



 



public void fun() {}



 



public final void wait(long arg-0, int arg-1) throws InterruptedException{}



 



public final native void wait(long arg-0) throws InterruptedException{}



 



public final void wait() throws InterruptedException{}



 



public boolean equals(Object arg-0) {}



 



public String toString() {}



 



public native int hashCode() {}



 



public final native Class getClass() {}



 



public final native void notify() {}



 



public final native void notifyAll() {}
```

通过打印的结果来看，手动拼接的没有直接获取的简单粗暴，看起来比较舒服，该有的都有，自己想要什么结果就可以拼接什么结果。



上面的代码一般在编写开发工具中实现，随笔提示就是此类代码的。上面所说的内容在在我们开发过程中是很少用到，那么肯定有人不明白，既然开发过程中用不到，为什么要说这么多了？

前面的知识都是让大家对Java的反射机制有个更好的认识，以及反射的基本使用方法。前面的算是热身，接下来要给大家介绍一个反射中比较重要的方法。



**5.反射中的invoke方法**



调用（invoke）：对带有指定参数的指定对象调用由此 `Method` 对象表示的底层方法。



```java
public Object invoke(Object obj,



                     Object... args)



              throws IllegalAccessException,



                     IllegalArgumentException,



                     InvocationTargetException
```

该方法的英文名字是invoke，中文名称就叫“调用”，该方法在Method类中，Method类本身就代表一个方法，当Method类中的对象调用invoke方法时，就相当于调用了Method对象所代表的方法，方法里面传入对应的参数，实现动态调用方法。这里可能比较难理解，看一下一个简单的实例：





```java
import java.lang.reflect.Method;



 



class Student4 {



	private String name;



 



	public String getName() {



		return name;



	}



 



	public void setName(String name) {



		this.name = name;



	}



}



 



public class ReflectInvokeDemo {



	public static void main(String[] args) throws Exception {



		Class<?> cls = Class.forName("com.iflytek.Student4");



		// 实例化对象



		Object obj = cls.newInstance();



		//获取setName()方法



		Method setNameMethod = cls.getMethod("setName", String.class);



		//获取getName()方法



		Method getNameMethod = cls.getMethod("getName");



		//调用setName()方法，相当于 对象.setName("马小超");



		setNameMethod.invoke(obj, "马小超");



		//调用getName()方法并输出



		System.out.println(getNameMethod.invoke(obj));



	}



}
```

上面的例子简单的实现了invoke的用法，在动态代理中和Spring框架中都用到了invoke方法，可以实现方法的动态调用，所以在程序设计时使用很广泛。




**6.利用反射调用类中的属性**

调用类中的属性和调用类中的方法差不多，也是分为两大类，每个大类里面分为两小类，如下：

获取包括继承而来的属性：

​         获取全部属性：

```java
public Field[] getFields()



                  throws SecurityException
```

​        获取指定属性：





```java
public Field getField(String name)



               throws NoSuchFieldException,



                      SecurityException
```

获取本类定义的属性：



​        获取全部属性：



```java
public Field[] getDeclaredFields()



                          throws SecurityException
```

​        获取指定的属性：





```java
public Field getDeclaredField(String name)



                       throws NoSuchFieldException,



                              SecurityException
```

利用反射获取类中的属性，是不提倡使用的，因为违背了面向对象的封装特性。

在Field类中定义了进行属性调用的方法：



设置属性内容：



```java
public void set(Object obj,



                Object value)



         throws IllegalArgumentException,



                IllegalAccessException
```

获取属性类容：





```java
public Object get(Object obj)



           throws IllegalArgumentException,



                  IllegalAccessException
```

实例：





```java
import java.lang.reflect.Field;



 



class Student5 {



 



	private String name;



 



}



 



public class ReflectFiledDemo {



	public static void main(String[] args) throws Exception {



		Class<?> cls = Class.forName("com.iflytek.Student5");



		//实例化



		Object obj = cls.newInstance();



		//获取属性



		Field nameField = cls.getDeclaredField("name");



		//取消访问检查



		<strong>nameField.setAccessible(true);</strong>



		//给属性赋值



		nameField.set(obj, "马小超");



		//获取属性值并输出



		System.out.println(nameField.get(obj));



	}



}
```

大家在阅读上面代码时会看到有一行代码被加粗了，为什么了？原因是Student类中的name属性是private属性的，不对外开放，如果Field类直接访问该属性，会报权限错误。



在Construction,Method,Field三个类中有一个共同的父类AccessibleObject，定义了取消封装的操作：setAccessible(Boolean flag)



```java
public void setAccessible(boolean flag)



                   throws SecurityException
```

该方法默认的是参数是false，表示反射的对象应该实施 Java 语言访问检查。值为

 

true

 

则指示反射的对象在使用时应该取消 Java 语言访问检查。



Java反射机制的基本概念及使用就这么多了，相信大家对反射已经不会感到很陌生了，后面我会介绍一下反射机制在工厂模式、代理模式以及Spring框架中的使用，让大家对反射有更深入的理解。